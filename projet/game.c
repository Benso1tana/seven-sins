#include "game.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#ifndef _WIN32
#include <errno.h>
#endif

#ifndef _MAX_PATH
#define _MAX_PATH 260
#endif

static const SDL_Color OBSTACLE_FLASH_COLORS[] = {
    {.r=255,.g=0,.b=0,.unused=0},{.r=0,.g=255,.b=0,.unused=0},
    {.r=0,.g=0,.b=255,.unused=0},{.r=255,.g=255,.b=0,.unused=0}
};

// --- Fonctions Utilitaires Statiques ---
// [ ... check_collision, get_pixel, put_pixel ... ]
int check_collision(SDL_Rect a, SDL_Rect b) { if (a.w <= 0 || a.h <= 0 || b.w <= 0 || b.h <= 0) return 0; return !(a.y + a.h <= b.y || a.y >= b.y + b.h || a.x + a.w <= b.x || a.x >= b.x + b.w); }
static Uint32 get_pixel(SDL_Surface *s, int x, int y) { if (!s||x<0||x>=s->w||y<0||y>=s->h)return 0; int bpp=s->format->BytesPerPixel; Uint8 *p=(Uint8*)s->pixels+y*s->pitch+x*bpp; switch(bpp){ case 1: return *p; case 2: return *(Uint16*)p; case 3: return(SDL_BYTEORDER==SDL_BIG_ENDIAN)?p[0]<<16|p[1]<<8|p[2]:p[0]|p[1]<<8|p[2]<<16; case 4: return *(Uint32*)p; default: return 0; } }
static void put_pixel(SDL_Surface *s, int x, int y, Uint32 px) { if (!s||x<0||x>=s->w||y<0||y>=s->h) return; int bpp=s->format->BytesPerPixel; Uint8 *p=(Uint8*)s->pixels+y*s->pitch+x*bpp; switch(bpp){ case 1:*p=px;break; case 2:*(Uint16*)p=px;break; case 3:if(SDL_BYTEORDER==SDL_BIG_ENDIAN){p[0]=(px>>16)&0xff;p[1]=(px>>8)&0xff;p[2]=px&0xff;}else{p[0]=px&0xff;p[1]=(px>>8)&0xff;p[2]=(px>>16)&0xff;}break; case 4:*(Uint32*)p=px; break;} }


// --- Timer et Textes ---
// [ ... update_timer, draw_final_time, load_texts, check_texts, draw_texts ... ]
void update_timer(GameTimer *t) { if (!t || !t->font) return; Uint32 elapsed_ms = SDL_GetTicks() - t->start_ticks; Uint32 sec = elapsed_ms / 1000; char buf[32]; snprintf(buf, sizeof(buf), "Time: %02u:%02u", sec / 60, sec % 60); SDL_Color white = {255, 255, 255, 0}; if (t->time_surface) SDL_FreeSurface(t->time_surface); t->time_surface = TTF_RenderText_Solid(t->font, buf, white); if (!t->time_surface) fprintf(stderr, "Warn: TTF_RenderText_Solid timer err: %s\n", TTF_GetError()); t->total_time = elapsed_ms; }
static void draw_final_time(Background *bg, SDL_Surface *screen) { if (!bg || !screen || !bg->timer.font) return; char buf[64]; Uint32 sec = bg->timer.total_time / 1000; snprintf(buf, sizeof(buf), "Final Time: %02u:%02u", sec / 60, sec % 60); SDL_Color yellow = {255, 255, 0, 0}; SDL_Surface *fs = TTF_RenderText_Solid(bg->timer.font, buf, yellow); if (fs) { SDL_Rect pos = {(SCREEN_WIDTH - fs->w) / 2, (SCREEN_HEIGHT - fs->h) / 2, 0, 0}; SDL_BlitSurface(fs, NULL, screen, &pos); SDL_FreeSurface(fs); } else fprintf(stderr, "Warn: TTF_RenderText_Solid final time err: %s\n", TTF_GetError()); }
static void load_texts(Background *bg) { if (!bg || !bg->timer.font) return; SDL_Color white = {255, 255, 255, 0}; const char *msgs[3] = {"W to jump", "Challenge!", "Congrats! X->Lvl2"}; int xs[3] = {900, 2500, 7600}; for (int i = 0; i < 3; ++i) { if (bg->texts[i].surface) SDL_FreeSurface(bg->texts[i].surface); strncpy(bg->texts[i].text, msgs[i], sizeof(bg->texts[i].text) - 1); bg->texts[i].text[sizeof(bg->texts[i].text) - 1] = '\0'; bg->texts[i].surface = TTF_RenderText_Solid(bg->timer.font, msgs[i], white); bg->texts[i].active = (bg->texts[i].surface != NULL); if (!bg->texts[i].active) fprintf(stderr, "Warn render text %d\n", i); bg->texts[i].position = (SDL_Rect){xs[i], 300, 0, 0}; bg->texts[i].is_showing = 0; bg->texts[i].show_time = 0; } }
static void check_texts(Background *bg) { if (!bg) return; Uint32 now = SDL_GetTicks(); for (int i = 0; i < 3; ++i) { GameText *txt = &bg->texts[i]; if (!txt->active) continue; if (txt->is_showing) { if (now - txt->show_time > TEXT_DISPLAY_TIME) { txt->is_showing = 0; txt->active = 0; if (txt->surface) { SDL_FreeSurface(txt->surface); txt->surface = NULL; } } } else { int tx = txt->position.x; if (tx >= bg->camera.x && tx < (bg->camera.x + bg->camera.w)) { txt->is_showing = 1; txt->show_time = now; } } } }
static void draw_texts(Background *bg, SDL_Surface *screen) { if (!bg || !screen) return; for (int i = 0; i < 3; ++i) { GameText *txt = &bg->texts[i]; if (txt->active && txt->is_showing && txt->surface) { SDL_Rect sp = {txt->position.x - bg->camera.x, txt->position.y - bg->camera.y, 0, 0}; if (sp.x < SCREEN_WIDTH && sp.x + txt->surface->w > 0 && sp.y < SCREEN_HEIGHT && sp.y + txt->surface->h > 0) { SDL_BlitSurface(txt->surface, NULL, screen, &sp); } } } }

// --- Gestion Plateformes ---
// [ ... add_platform, update_platforms ... ]
static void add_platform(Background *bg, const char *img, int wx, int wy, PlatformType t, int mr) { if (!bg) return; bg->platform_count++; Platform *tmp = realloc(bg->platforms, bg->platform_count * sizeof(Platform)); if (!tmp) { fprintf(stderr, "Err realloc plat\n"); bg->platform_count--; return; } bg->platforms = tmp; Platform *p = &bg->platforms[bg->platform_count - 1]; p->image = IMG_Load(img); if (!p->image) { fprintf(stderr, "Err load plat %s: %s\n", img, IMG_GetError()); p->image = NULL; p->position = (SDL_Rect){wx, wy, 0, 0};} else p->position = (SDL_Rect){wx, wy, p->image->w, p->image->h}; p->type = t; p->move_range = mr; p->move_direction = 1; p->original_x = wx; p->original_y = wy; }
void update_platforms(Background *bg) { if (!bg || !bg->platforms) return; for (int i = 0; i < bg->platform_count; ++i) { Platform *p = &bg->platforms[i]; if (p->type == PLATFORM_MOBILE_H && p->image) { p->position.x += MOBILE_PLATFORM_SPEED * p->move_direction; if (p->move_direction > 0 && p->position.x >= p->original_x + p->move_range) { p->position.x = p->original_x + p->move_range; p->move_direction = -1; } else if (p->move_direction < 0 && p->position.x <= p->original_x - p->move_range) { p->position.x = p->original_x - p->move_range; p->move_direction = 1; } } } }

// --- Gestion Background et Caméra ---
// [ ... init_background, free_background, update_camera, render_all ... ]
void init_background(Background *bg, int level, Uint32 st) { printf(" init_background L%d\n", level); if(!bg) return; if(bg->bg_image){SDL_FreeSurface(bg->bg_image);bg->bg_image=NULL;} if(bg->hole_img){SDL_FreeSurface(bg->hole_img);bg->hole_img=NULL;} if(bg->platforms){for(int i=0;i<bg->platform_count;++i)if(bg->platforms[i].image)SDL_FreeSurface(bg->platforms[i].image);free(bg->platforms);} bg->platforms=NULL;bg->platform_count=0; for(int i=0;i<3;++i){if(bg->texts[i].surface)SDL_FreeSurface(bg->texts[i].surface);bg->texts[i].surface=NULL;bg->texts[i].active=0;bg->texts[i].is_showing=0;} if(bg->timer.time_surface)SDL_FreeSurface(bg->timer.time_surface);bg->timer.time_surface=NULL; bg->level=level;bg->show_final_time=0; const char *bf=(level==1)?"bg1.png":"bg2.png";bg->bg_image=IMG_Load(bf);if(!bg->bg_image)fprintf(stderr,"Err load bg %s\n",bf); bg->camera=(SDL_Rect){0,(level==1?INITIAL_CAMERA_Y:50),SCREEN_WIDTH,SCREEN_HEIGHT}; bg->hole_img=IMG_Load("hole.png");if(!bg->hole_img)printf("Warn hole load\n"); bg->timer.start_ticks=st; if(!bg->timer.font)fprintf(stderr,"ERR BG FONT NULL\n"); if(level==1)load_texts(bg); printf(" Adding plats...\n"); if(level==1){add_platform(bg,"blocf.png",1150,665,PLATFORM_FIXED,0);add_platform(bg,"poubf.png",3400,670,PLATFORM_FIXED,0);add_platform(bg,"carnet.png",2800,810,PLATFORM_FIXED,0);add_platform(bg,"balle1.png",4880,150,PLATFORM_FIXED,0);add_platform(bg,"balle1.png",2000,150,ITEM_HOLE,0);add_platform(bg,"glass2.png",1820,770,ITEM_HOLE,0);add_platform(bg,"poubm.png",5500,540,PLATFORM_FIXED,0);add_platform(bg,"carnet.png",4200,810,PLATFORM_FIXED,0);add_platform(bg,"wod.png",7550,330,PLATFORM_FIXED,0);} else {add_platform(bg,"blocm.png",1300,625,PLATFORM_FIXED,0);add_platform(bg,"poubd.png",3800,530,PLATFORM_FIXED,0);add_platform(bg,"carnet.png",710,830,PLATFORM_FIXED,0);add_platform(bg,"pic.png",2400,680,PLATFORM_FIXED,0);add_platform(bg,"blocd.png",5520,600,ITEM_HOLE,0);add_platform(bg,"loupe.png",6700,800,PLATFORM_PUZZLE_TRIGGER,0);} printf(" BG Init OK. Plats: %d\n", bg->platform_count); }
void free_background(Background *bg) { printf("Freeing BG...\n"); if(!bg)return; if(bg->bg_image){SDL_FreeSurface(bg->bg_image);bg->bg_image=NULL;} if(bg->hole_img){SDL_FreeSurface(bg->hole_img);bg->hole_img=NULL;} if(bg->platforms){for(int i=0;i<bg->platform_count;++i)if(bg->platforms[i].image)SDL_FreeSurface(bg->platforms[i].image);free(bg->platforms);}bg->platforms=NULL;bg->platform_count=0; for(int i=0;i<3;++i){if(bg->texts[i].surface)SDL_FreeSurface(bg->texts[i].surface);bg->texts[i].surface=NULL;} if(bg->timer.time_surface){SDL_FreeSurface(bg->timer.time_surface);}bg->timer.time_surface=NULL; bg->timer.font=NULL; printf("BG Freed.\n"); }
void update_camera(Background *bg, SDL_Rect player_pos) { if(!bg)return; if(player_pos.x<bg->camera.x+CAMERA_FOLLOW_MARGIN_X){bg->camera.x=player_pos.x-CAMERA_FOLLOW_MARGIN_X;}else if(player_pos.x+player_pos.w>bg->camera.x+SCREEN_WIDTH-CAMERA_FOLLOW_MARGIN_X){bg->camera.x=player_pos.x+player_pos.w-SCREEN_WIDTH+CAMERA_FOLLOW_MARGIN_X;} if(player_pos.y<bg->camera.y+CAMERA_FOLLOW_MARGIN_Y){bg->camera.y=player_pos.y-CAMERA_FOLLOW_MARGIN_Y;}else if(player_pos.y+player_pos.h>bg->camera.y+SCREEN_HEIGHT-CAMERA_FOLLOW_MARGIN_Y){bg->camera.y=player_pos.y+player_pos.h-SCREEN_HEIGHT+CAMERA_FOLLOW_MARGIN_Y;} if(bg->camera.x<0){bg->camera.x=0;} if(bg->camera.y<0){bg->camera.y=0;} int wl_x=WORLD_WIDTH-SCREEN_WIDTH;if(wl_x<0)wl_x=0; if(bg->camera.x>wl_x)bg->camera.x=wl_x; if(bg->bg_image){int wl_y=bg->bg_image->h-SCREEN_HEIGHT;if(wl_y<0)wl_y=0;if(bg->camera.y>wl_y)bg->camera.y=wl_y;} }
void render_all(Background *bg, SDL_Surface *scr) { if(!bg||!scr)return; if(bg->bg_image){SDL_Rect src={bg->camera.x,bg->camera.y,SCREEN_WIDTH,SCREEN_HEIGHT};SDL_Rect dest={0,0,0,0};SDL_BlitSurface(bg->bg_image,&src,scr,&dest);}else{SDL_FillRect(scr,NULL,SDL_MapRGB(scr->format,50,50,50));} if(bg->platforms){for(int i=0;i<bg->platform_count;++i){Platform*p=&bg->platforms[i];SDL_Surface*img=p->image;if(p->type==ITEM_HOLE&&bg->hole_img)img=bg->hole_img;if(!img)continue;SDL_Rect d={p->position.x-bg->camera.x,p->position.y-bg->camera.y,0,0};if(d.x<SCREEN_WIDTH&&d.x+p->position.w>0&&d.y<SCREEN_HEIGHT&&d.y+p->position.h>0)SDL_BlitSurface(img,NULL,scr,&d);}} check_texts(bg);draw_texts(bg,scr); if(bg->timer.time_surface&&!bg->show_final_time){SDL_Rect td={10,10,0,0};SDL_BlitSurface(bg->timer.time_surface,NULL,scr,&td);} if(bg->show_final_time)draw_final_time(bg,scr); }

// --- Gestion Ennemis ---
// [ ... initialiser_animation_enemy, initialiser_ennemi, liberer_ennemi, deplacer_ennemi, animer_ennemi, ennemi_shoot, detecter_collision_joueur_ennemi, gerer_sante_ennemi, afficher_ennemi_on_screen ... ]
static Animation* initialiser_animation_enemy(const char *p, int n, int d) { Animation *a=(Animation*)malloc(sizeof(Animation)); if(!a)return NULL; a->frames=(SDL_Surface**)malloc(sizeof(SDL_Surface*)*n); if(!a->frames){free(a);return NULL;} for(int i=0;i<n;++i)a->frames[i]=NULL; char path[_MAX_PATH];int ok=1;SDL_Surface*tmp=NULL; for(int i=0;i<n;++i){snprintf(path,_MAX_PATH,"%s%d.png",p,i);tmp=IMG_Load(path);if(!tmp){fprintf(stderr,"Anim load err %s\n",path);ok=0;}a->frames[i]=tmp;if(a->frames[i] && SDL_SetColorKey(a->frames[i],SDL_SRCCOLORKEY|SDL_RLEACCEL,SDL_MapRGB(a->frames[i]->format,0,255,0))!=0)fprintf(stderr,"Warn colorkey %s\n",path);} if(!ok && !a->frames[0]){for(int j=0;j<n;++j)if(a->frames[j])SDL_FreeSurface(a->frames[j]);free(a->frames);free(a);return NULL;} a->frame_actuelle=0;a->nb_frames=n;a->delai_frame=d;a->compteur_delai=0;a->direction=DIR_RIGHT; return a; }
Ennemi* initialiser_ennemi(int niveau, int start_x, int start_y) { (void)niveau; printf("Init Enemy (%d, %d)...\n", start_x, start_y); Ennemi *e = (Ennemi*) malloc(sizeof(Ennemi)); if (!e) return NULL; memset(e, 0, sizeof(Ennemi)); e->position = (SDL_Rect){start_x, start_y, 0, 0}; e->vitesse_x = 1; e->direction = DIR_LEFT; e->health = ENNEMI_HEALTH_MAX; e->temps_changement_direction = 240; e->shoot_delay = 90; e->animations = (Animation**) malloc(sizeof(Animation*) * 4); if (!e->animations) { free(e); return NULL; } for(int i=0; i<4; ++i) e->animations[i]=NULL; e->animations[ANIM_MOVE*2+DIR_RIGHT] = initialiser_animation_enemy("ennemi_move_right_", 2, 20); if (!e->animations[ANIM_MOVE*2+DIR_RIGHT]){ liberer_ennemi(e); return NULL; } e->animations[ANIM_SHOOT*2+DIR_RIGHT] = initialiser_animation_enemy("ennemi_shoot_", 1, 30); if (!e->animations[ANIM_SHOOT*2+DIR_RIGHT]){ liberer_ennemi(e); return NULL; } e->animations[ANIM_MOVE*2+DIR_LEFT] = e->animations[ANIM_MOVE*2+DIR_RIGHT]; e->animations[ANIM_SHOOT*2+DIR_LEFT] = e->animations[ANIM_SHOOT*2+DIR_RIGHT]; if (e->animations[ANIM_MOVE*2+DIR_RIGHT]->frames[0]) { e->position.w = e->animations[ANIM_MOVE*2+DIR_RIGHT]->frames[0]->w; e->position.h = e->animations[ANIM_MOVE*2+DIR_RIGHT]->frames[0]->h; printf("  Enemy dim: %dx%d\n", e->position.w, e->position.h); } else { e->position.w=32; e->position.h=32; printf("  Warn: Enemy default dims\n");} printf("Enemy Initialized.\n"); return e; }
void liberer_ennemi(Ennemi *e) { if (!e) return; if (e->animations) { Animation *ma=e->animations[ANIM_MOVE*2+DIR_RIGHT]; Animation *sa=e->animations[ANIM_SHOOT*2+DIR_RIGHT]; if(ma){ if(ma->frames){for(int j=0;j<ma->nb_frames;++j) if(ma->frames[j]) SDL_FreeSurface(ma->frames[j]); free(ma->frames);} free(ma); } if(sa && sa != ma){ if(sa->frames){for(int j=0;j<sa->nb_frames;++j) if(sa->frames[j]) SDL_FreeSurface(sa->frames[j]); free(sa->frames);} free(sa); } free(e->animations); } free(e); }
void deplacer_ennemi(Ennemi *e, SDL_Rect l, SDL_Rect pp) { if (!e || e->health <= 0) return; int dx_abs=abs((pp.x+pp.w/2)-(e->position.x+e->position.w/2)); int range=(dx_abs<ENNEMY_ATTACK_RANGE); if(range){ if(!e->est_en_attaque){ e->est_en_attaque=1; e->shoot_timer=0; Animation* sa=e->animations[ANIM_SHOOT*2+DIR_RIGHT]; if(sa) sa->frame_actuelle=0;} e->direction=((pp.x+pp.w/2)<(e->position.x+e->position.w/2))?DIR_LEFT:DIR_RIGHT; e->compteur_temps=0;} else { if(e->est_en_attaque){ e->est_en_attaque=0; e->compteur_temps=0; Animation* ma=e->animations[ANIM_MOVE*2+DIR_RIGHT]; if(ma) ma->frame_actuelle=0;} e->compteur_temps++; if(e->compteur_temps>=e->temps_changement_direction){ e->compteur_temps=0; e->direction=(e->direction==DIR_LEFT)?DIR_RIGHT:DIR_LEFT;} e->position.x+=(e->direction==DIR_LEFT)?-e->vitesse_x:e->vitesse_x; if(e->position.x<l.x){e->position.x=l.x;e->direction=DIR_RIGHT;e->compteur_temps=0;} else if(e->position.x+e->position.w>l.x+l.w){e->position.x=l.x+l.w-e->position.w;e->direction=DIR_LEFT;e->compteur_temps=0;} } }
void animer_ennemi(Ennemi *e) { if (!e || !e->animations || e->health <= 0) return; Animation *a=NULL; int type=e->est_en_attaque?ANIM_SHOOT:ANIM_MOVE; a=e->animations[type*2+DIR_RIGHT]; if (a && a->frames) { int nbf=0; for(int i=0;i<a->nb_frames;++i) if(a->frames[i]) nbf++; else break; if(nbf>0){ a->compteur_delai++; if (a->compteur_delai >= a->delai_frame) { a->compteur_delai = 0; a->frame_actuelle = (a->frame_actuelle + 1) % nbf; } } } }
void ennemi_shoot(Ennemi *e, Projectile *b, SDL_Rect pp) { if (!e || !b || e->health <= 0 || !e->est_en_attaque || b->active) return; e->shoot_timer++; if (e->shoot_timer >= e->shoot_delay) { float ecx=e->position.x+e->position.w/2.0f, ecy=e->position.y+e->position.h/2.0f, pcx=pp.x+pp.w/2.0f, pcy=pp.y+pp.h/2.0f; float dx=pcx-ecx, dy=pcy-ecy, dist=sqrtf(dx*dx+dy*dy); b->active=1; b->real_x=ecx-b->pos.w/2.0f; b->real_y=ecy-b->pos.h/2.0f; b->pos.x=(int)b->real_x; b->pos.y=(int)b->real_y; if(dist>0.1f){ b->vx=(dx/dist)*ENNEMY_BULLET_SPEED; b->vy=(dy/dist)*ENNEMY_BULLET_SPEED;} else {b->vx=(e->direction==DIR_LEFT)?-ENNEMY_BULLET_SPEED:ENNEMY_BULLET_SPEED; b->vy=0.0f;} e->shoot_timer=0; } }
int detecter_collision_joueur_ennemi(SDL_Rect pj, Ennemi *e) { if (!e || e->health <= 0) return 0; return check_collision(pj, e->position); }
void gerer_sante_ennemi(Ennemi *e, int dmg) { if (!e || e->health <= 0 || dmg <= 0) return; e->health -= dmg; if (e->health < 0) e->health = 0; printf("Enemy health: %d/%d\n", e->health, ENNEMI_HEALTH_MAX); if (e->health == 0) e->est_en_attaque = 0; }
void afficher_ennemi_on_screen(Ennemi *e, SDL_Surface *scr, SDL_Rect cam) { if (!e || !scr || !e->animations || e->health <= 0) return; SDL_Surface *frm=NULL; Animation *anim=NULL; int type=e->est_en_attaque?ANIM_SHOOT:ANIM_MOVE; anim=e->animations[type*2+DIR_RIGHT]; if(anim && anim->frames && anim->frame_actuelle>=0 && anim->frame_actuelle<anim->nb_frames && anim->frames[anim->frame_actuelle]) frm=anim->frames[anim->frame_actuelle]; if(!frm && e->animations[ANIM_MOVE*2+DIR_RIGHT] && e->animations[ANIM_MOVE*2+DIR_RIGHT]->frames && e->animations[ANIM_MOVE*2+DIR_RIGHT]->nb_frames>0 && e->animations[ANIM_MOVE*2+DIR_RIGHT]->frames[0]) frm=e->animations[ANIM_MOVE*2+DIR_RIGHT]->frames[0]; if(!frm) return; if(e->position.w==0){e->position.w=frm->w;e->position.h=frm->h;} int flip=(e->direction==DIR_LEFT); SDL_Rect sp={e->position.x-cam.x, e->position.y-cam.y, 0, 0}; if(sp.x<SCREEN_WIDTH && sp.x+e->position.w>0 && sp.y<SCREEN_HEIGHT && sp.y+e->position.h>0){ if(!flip) SDL_BlitSurface(frm,NULL,scr,&sp); else { SDL_Surface *f=SDL_CreateRGBSurface(SDL_SWSURFACE,frm->w,frm->h,frm->format->BitsPerPixel,frm->format->Rmask,frm->format->Gmask,frm->format->Bmask,frm->format->Amask); if(f){if(SDL_MUSTLOCK(frm))SDL_LockSurface(frm);if(SDL_MUSTLOCK(f))SDL_LockSurface(f);int w=frm->w,h=frm->h;for(int y=0;y<h;++y){for(int x=0;x<w;++x){put_pixel(f,w-1-x,y,get_pixel(frm,x,y));}}if(SDL_MUSTLOCK(frm))SDL_UnlockSurface(frm);if(SDL_MUSTLOCK(f))SDL_UnlockSurface(f);if(frm->flags&SDL_SRCCOLORKEY)SDL_SetColorKey(f,SDL_SRCCOLORKEY|SDL_RLEACCEL,frm->format->colorkey);if(frm->flags&SDL_SRCALPHA)SDL_SetAlpha(f,SDL_SRCALPHA|SDL_RLEACCEL,frm->format->alpha);SDL_BlitSurface(f,NULL,scr,&sp);SDL_FreeSurface(f);} else SDL_BlitSurface(frm,NULL,scr,&sp); } } }

// --- Gestion Joueur ---
// [ ... charger_animation_player, charger_life_images, init_player, free_player, update_player_animation, render_player, render_player_hud, player_take_damage, player_gain_life, player_shoot ... ]
static int charger_animation_player(SDL_Surface* images[], const char* folder, int nb_frames_max) { char filename[128]; printf("    Chargement anim player '%s'...\n", folder); int frames_charges = 0; for (int i = 0; i < nb_frames_max; i++) { snprintf(filename, sizeof(filename), "%s/%d.png", folder, i); images[i] = IMG_Load(filename); if (!images[i]) { if (i==0)fprintf(stderr,"ERR Ld %s\n", filename); images[i]=NULL; } else { frames_charges++; if(SDL_SetColorKey(images[i], SDL_SRCCOLORKEY|SDL_RLEACCEL, SDL_MapRGB(images[i]->format, 0, 255, 0))!=0) fprintf(stderr,"Warn CK %s\n",filename); } } printf("    -> %d/%d frames.\n", frames_charges, nb_frames_max); return (images[0] != NULL); }
static int charger_life_images(SDL_Surface* life_images[]) { char filename[128]; int success = 1; printf("    Chargement life images...\n"); for (int i = 0; i < LIFE_STATES; i++) { snprintf(filename, sizeof(filename), "life/%d.png", i); life_images[i] = IMG_Load(filename); if (!life_images[i]) { fprintf(stderr, "ERR Ld %s\n", filename); life_images[i] = NULL; success = 0; } else { if (SDL_SetColorKey(life_images[i], SDL_SRCCOLORKEY|SDL_RLEACCEL, SDL_MapRGB(life_images[i]->format, 0, 0, 0)) != 0) fprintf(stderr, "Warn CK %s\n", filename); } } return success; }
int init_player(Player *p) { if (!p) return 0; printf("  Init Joueur...\n"); memset(p, 0, sizeof(Player)); int crit_ok = 1; crit_ok &= charger_animation_player(p->images[ANIM_WALK_RIGHT], "animation/walk_right", NB_FRAMES); crit_ok &= charger_animation_player(p->images[ANIM_WALK_LEFT], "animation/walk_left", NB_FRAMES); crit_ok &= charger_animation_player(p->images[ANIM_ATTACK], "animation/attack", NB_FRAMES); crit_ok &= charger_animation_player(p->images[ANIM_JUMP], "animation/jump", NB_FRAMES); if (!crit_ok || !p->images[ANIM_WALK_RIGHT][0]) { fprintf(stderr, "ERR FATAL: Anim joueur critique.\n"); free_player(p); return 0; } if (!charger_life_images(p->life_images)) fprintf(stderr, "WARN: Images vie manquantes.\n"); p->direction = 0; p->current_action = ANIM_WALK_RIGHT; p->last_frame_time = SDL_GetTicks(); p->on_ground = 1; p->life_state = 0; p->pos.w = p->images[ANIM_WALK_RIGHT][0]->w; p->pos.h = p->images[ANIM_WALK_RIGHT][0]->h; p->pos.x = 100; p->pos.y = WORLD_FLOOR_Y - p->pos.h; printf("  Joueur Init (pos=%d,%d size=%dx%d).\n", p->pos.x, p->pos.y, p->pos.w, p->pos.h); return 1; }
void free_player(Player *p) { if (!p) return; for(int i=0; i<NB_ACTIONS; ++i) for(int j=0; j<NB_FRAMES; ++j) if(p->images[i][j]) {SDL_FreeSurface(p->images[i][j]); p->images[i][j]=NULL;} for(int i=0; i<LIFE_STATES; ++i) if(p->life_images[i]) {SDL_FreeSurface(p->life_images[i]); p->life_images[i]=NULL;} }
void update_player_animation(Player *p) { if (!p) return; Uint32 now = SDL_GetTicks(); int prev_act = p->current_action; int is_idle = p->on_ground && fabs(p->vx) < 0.1f && !p->attacking; int next_act = p->current_action; if (p->attacking) { next_act = ANIM_ATTACK; } else if (!p->on_ground) { next_act = ANIM_JUMP; } else if (!is_idle) { next_act = (p->direction == 0) ? ANIM_WALK_RIGHT : ANIM_WALK_LEFT; } else { next_act = (p->direction == 0) ? ANIM_WALK_RIGHT : ANIM_WALK_LEFT; } if (next_act != prev_act) { p->current_frame = 0; p->last_frame_time = now; } p->current_action = next_act; Uint32 interval = (p->current_action == ANIM_ATTACK) ? PLAYER_ATTACK_FRAME_INTERVAL : PLAYER_FRAME_INTERVAL; if (now - p->last_frame_time >= interval) { p->last_frame_time = now; if (!is_idle || p->attacking || !p->on_ground ) { int nbf = 0; if (p->current_action<NB_ACTIONS && p->images[p->current_action]) { for(int i=0; i<NB_FRAMES; ++i) if(p->images[p->current_action][i]) nbf++; else break; } if(nbf==0) nbf=1; p->current_frame = (p->current_frame + 1) % nbf; if (p->current_action==ANIM_ATTACK && p->current_frame==0 && prev_act==ANIM_ATTACK && p->attacking) { p->attacking = 0; } } else { p->current_frame = 0; } } if (is_idle && !p->attacking) { p->current_frame = 0; } SDL_Surface *cur_frm = NULL; if (p->current_action<NB_ACTIONS && p->current_frame<NB_FRAMES && p->images[p->current_action] && p->images[p->current_action][p->current_frame]) cur_frm=p->images[p->current_action][p->current_frame]; else if(p->images[ANIM_WALK_RIGHT][0]) cur_frm=p->images[ANIM_WALK_RIGHT][0]; if (cur_frm) { int old_h = p->pos.h; p->pos.w = cur_frm->w; p->pos.h = cur_frm->h; if (p->on_ground && p->pos.h != old_h) p->pos.y += (old_h - p->pos.h); } }
void render_player(Player *p, SDL_Surface *screen, SDL_Rect camera) { if (!p || !screen) return; SDL_Surface *frm=NULL; if (p->current_action<NB_ACTIONS && p->current_frame<NB_FRAMES && p->images[p->current_action] && p->images[p->current_action][p->current_frame]) frm=p->images[p->current_action][p->current_frame]; else if(p->images[ANIM_WALK_RIGHT][0]) frm=p->images[ANIM_WALK_RIGHT][0]; if (!frm) { SDL_Rect r={p->pos.x-camera.x, p->pos.y-camera.y, p->pos.w?p->pos.w:50, p->pos.h?p->pos.h:100}; SDL_FillRect(screen,&r,SDL_MapRGB(screen->format,255,0,255)); return; } SDL_Rect sp={p->pos.x-camera.x, p->pos.y-camera.y, 0, 0}; if(sp.x<SCREEN_WIDTH && sp.x+p->pos.w>0 && sp.y<SCREEN_HEIGHT && sp.y+p->pos.h>0) SDL_BlitSurface(frm, NULL, screen, &sp); }
void render_player_hud(Player *p, SDL_Surface *screen) { if (!p || !screen || p->life_state < 0 || p->life_state >= LIFE_STATES) return; SDL_Surface *img=p->life_images[p->life_state]; if (img) { SDL_Rect d={10,50, 0, 0}; SDL_BlitSurface(img, NULL, screen, &d); } }
void player_take_damage(Player *p, int amount) { if (!p || amount<=0 || p->life_state>=LIFE_STATES-1) return; p->life_state+=amount; if(p->life_state>=LIFE_STATES-1)p->life_state=LIFE_STATES-1; }
void player_gain_life(Player *p) { if (!p || p->life_state<=0) return; p->life_state--; printf("Player gain life! state=%d\n", p->life_state); }
void player_shoot(Game *game) { if(!game || game->player_bullet.active) return; Player *p=&game->player; Projectile *pb=&game->player_bullet; pb->active=1; pb->real_x=p->pos.x+p->pos.w/2.0f-pb->pos.w/2.0f; pb->real_y=p->pos.y+p->pos.h/2.0f-pb->pos.h/2.0f; pb->pos.x=(int)pb->real_x; pb->pos.y=(int)pb->real_y; pb->vx=(p->direction==0)?PLAYER_BULLET_SPEED:-PLAYER_BULLET_SPEED; pb->vy=0; }

// --- Minimap ---
// [ ... init_minimap, load_minimap_for_level, free_minimap, update_minimap, render_minimap ... ]
int init_minimap(MinimapData *mm) { if (!mm) return 0; printf("  Init Minimap...\n"); memset(mm, 0, sizeof(MinimapData)); mm->scale_x=1.0f; mm->scale_y=1.0f; mm->player_icon_img = IMG_Load(MINIMAP_PLAYER_ICON); if (!mm->player_icon_img) {fprintf(stderr,"ERR load %s\n",MINIMAP_PLAYER_ICON); return 0;} return 1;}
int load_minimap_for_level(MinimapData *mm, Background *bg, int lvl) { if(!mm)return 0; (void)bg; if(mm->minimap_bg_img) SDL_FreeSurface(mm->minimap_bg_img); mm->minimap_bg_img=NULL; const char* fn=NULL; if(lvl==1)fn=MINIMAP_BG_L1; else if(lvl==2)fn=MINIMAP_BG_L2; else return 0; printf("    Load minimap BG '%s'\n",fn); mm->minimap_bg_img=IMG_Load(fn); if(!mm->minimap_bg_img){fprintf(stderr,"ERR load %s\n",fn); return 0;} mm->minimap_screen_pos=(SDL_Rect){SCREEN_WIDTH-mm->minimap_bg_img->w-MINIMAP_SCREEN_X_OFFSET, MINIMAP_SCREEN_Y_OFFSET, mm->minimap_bg_img->w, mm->minimap_bg_img->h}; mm->scale_x=(float)mm->minimap_screen_pos.w/(float)WORLD_WIDTH; mm->scale_y=(float)mm->minimap_screen_pos.h/(float)WORLD_FLOOR_Y; printf("    Minimap BG loaded (Scale X:%.3f Y:%.3f)\n", mm->scale_x, mm->scale_y); return 1;}
void free_minimap(MinimapData *mm) { if(!mm) return; if(mm->minimap_bg_img)SDL_FreeSurface(mm->minimap_bg_img); if(mm->player_icon_img)SDL_FreeSurface(mm->player_icon_img); /*printf("Minimap freed\n");*/ }
void update_minimap(Game *g) { if(!g||!g->minimap.minimap_bg_img||!g->minimap.player_icon_img)return; MinimapData*m=&g->minimap; Player*p=&g->player; m->player_icon_minimap_pos.x=(int)(p->pos.x*m->scale_x); m->player_icon_minimap_pos.y=(int)(p->pos.y*m->scale_y); m->player_icon_minimap_pos.w=m->player_icon_img->w; m->player_icon_minimap_pos.h=m->player_icon_img->h; if(m->player_icon_minimap_pos.x<0)m->player_icon_minimap_pos.x=0; if(m->player_icon_minimap_pos.y<0)m->player_icon_minimap_pos.y=0; if(m->player_icon_minimap_pos.x+m->player_icon_minimap_pos.w > m->minimap_screen_pos.w) m->player_icon_minimap_pos.x=m->minimap_screen_pos.w-m->player_icon_minimap_pos.w; if(m->player_icon_minimap_pos.y+m->player_icon_minimap_pos.h > m->minimap_screen_pos.h) m->player_icon_minimap_pos.y=m->minimap_screen_pos.h-m->player_icon_minimap_pos.h; Uint32 now=SDL_GetTicks(); if(now-g->obstacle_flash_timer>=MINIMAP_OBSTACLE_FLASH_INTERVAL){g->obstacle_flash_timer=now;g->current_obstacle_color_index=(g->current_obstacle_color_index+1)%4;} }
void render_minimap(Game *g) { if (!g||!g->screen||!g->minimap.minimap_bg_img||!g->minimap.player_icon_img)return; MinimapData*mm=&g->minimap; Background*bg=&g->background; SDL_Surface*s=g->screen; SDL_BlitSurface(mm->minimap_bg_img,NULL,s,&mm->minimap_screen_pos); SDL_Rect clip; SDL_GetClipRect(s,&clip); SDL_SetClipRect(s,&mm->minimap_screen_pos); SDL_Color fc=OBSTACLE_FLASH_COLORS[g->current_obstacle_color_index]; Uint32 fC=SDL_MapRGB(s->format,fc.r,fc.g,fc.b); for(int i=0;i<bg->platform_count;++i){ Platform*p=&bg->platforms[i]; if(p->type==ITEM_HOLE||p->type==PLATFORM_PUZZLE_TRIGGER||!p->image)continue; SDL_Rect r; r.x=(int)(p->position.x*mm->scale_x)+mm->minimap_screen_pos.x; r.y=(int)(p->position.y*mm->scale_y)+mm->minimap_screen_pos.y; r.w=(int)(p->position.w*mm->scale_x); if(r.w<1)r.w=1; r.h=(int)(p->position.h*mm->scale_y); if(r.h<1)r.h=1; SDL_FillRect(s,&r,fC); } Uint32 eC=SDL_MapRGB(s->format,255,0,0); for(int i=0;i<MAX_ENEMIES;++i)if(g->enemies[i]&&g->enemies[i]->health>0){Ennemi*e=g->enemies[i]; SDL_Rect d; d.x=(int)(e->position.x*mm->scale_x)+mm->minimap_screen_pos.x-MINIMAP_ENEMY_DOT_SIZE/2; d.y=(int)(e->position.y*mm->scale_y)+mm->minimap_screen_pos.y-MINIMAP_ENEMY_DOT_SIZE/2; d.w=MINIMAP_ENEMY_DOT_SIZE; d.h=MINIMAP_ENEMY_DOT_SIZE; SDL_FillRect(s,&d,eC);} SDL_Rect ppos=mm->player_icon_minimap_pos; if(g->is_minimap_shaking){ppos.x+=(rand()%(MINIMAP_SHAKE_AMPLITUDE*2+1))-MINIMAP_SHAKE_AMPLITUDE; ppos.y+=(rand()%(MINIMAP_SHAKE_AMPLITUDE*2+1))-MINIMAP_SHAKE_AMPLITUDE;} ppos.x+=mm->minimap_screen_pos.x; ppos.y+=mm->minimap_screen_pos.y; SDL_BlitSurface(mm->player_icon_img,NULL,s,&ppos); SDL_SetClipRect(s,&clip); }

// --- Puzzle Integration ---
PuzzleState run_puzzle(Game *g) { if(!g) return PUZZLE_STATE_LOST; printf("--- Puzzle ---\n"); g->game_state=STATE_PUZZLE; const char* pp[9]={"0.png","1.png","2.png","3.png","4.png","5.png","6.png","7.png","8.png"}; puzzle_init(&g->puzzle_instance,pp); g->puzzle_instance.font=g->puzzle_font; if(g->puzzle_instance.state==PUZZLE_STATE_LOST){fprintf(stderr,"Puzzle Init Fail\n");puzzle_cleanup(&g->puzzle_instance);g->game_state=STATE_RUNNING;return PUZZLE_STATE_LOST;} SDL_Event ev; int run=1; PuzzleState res=PUZZLE_STATE_RUNNING; while(run&&g->running){ while(SDL_PollEvent(&ev)){if(ev.type==SDL_QUIT){g->running=0;run=0;res=PUZZLE_STATE_LOST;}else if(ev.type==SDL_KEYDOWN&&ev.key.keysym.sym==SDLK_ESCAPE){run=0;res=PUZZLE_STATE_LOST;}else{puzzle_handle_event(&g->puzzle_instance,&ev);}} puzzle_update(&g->puzzle_instance); puzzle_render(&g->puzzle_instance,g->screen); SDL_Flip(g->screen); if(g->puzzle_instance.state!=PUZZLE_STATE_RUNNING){res=g->puzzle_instance.state;run=0;if(res!=PUZZLE_STATE_RUNNING)SDL_Delay(1500);} SDL_Delay(10);} puzzle_cleanup(&g->puzzle_instance); g->game_state=STATE_RUNNING; printf("--- Exit Puzzle ---\n"); return res;}

// --- Gestion de Niveau et Jeu Principal ---
void change_level(Game *g, int nl) { if(!g)return; printf("Change Lvl %d\n",nl); for(int i=0;i<MAX_ENEMIES;++i)if(g->enemies[i]){liberer_ennemi(g->enemies[i]);g->enemies[i]=NULL;} g->current_level=nl; g->start_time=SDL_GetTicks(); Player*p=&g->player;p->pos.x=100;if(p->images[ANIM_WALK_RIGHT][0])p->pos.h=p->images[ANIM_WALK_RIGHT][0]->h;else p->pos.h=100; p->pos.y=WORLD_FLOOR_Y-p->pos.h;p->vx=0;p->vy=0;p->on_ground=1;p->life_state=0;p->attacking=0;p->current_action=ANIM_WALK_RIGHT;p->current_frame=0;g->player_bullet.active=0;g->enemy_bullet.active=0;g->background.camera.x=0;g->background.camera.y=(nl==1?INITIAL_CAMERA_Y:50); if(!g->background.timer.font)g->background.timer.font=g->puzzle_font; if(!g->background.timer.font){fprintf(stderr,"ERR Font L%d\n",nl);g->running=0;return;} init_background(&g->background,g->current_level,g->start_time); if(!load_minimap_for_level(&g->minimap,&g->background,g->current_level)){fprintf(stderr,"ERR Minimap L%d\n",nl);g->running=0;return;} g->obstacle_flash_timer=SDL_GetTicks();g->current_obstacle_color_index=0; printf(" Init enemies L%d\n",nl);int si=0;if(nl==1){if(MAX_ENEMIES>=1){g->enemies[0]=initialiser_ennemi(nl,6550,ENEMY_SPAWN_Y);if(!g->enemies[0]){g->running=0;return;}si=1;}}else if(nl==2){if(MAX_ENEMIES>=1){g->enemies[0]=initialiser_ennemi(nl,7500,ENEMY_SPAWN_Y);if(!g->enemies[0]){g->running=0;return;}si=1;}} for(int i=si;i<MAX_ENEMIES;++i)g->enemies[i]=NULL;printf("Lvl %d Ready\n",nl);}

// Signature restaurée pour accepter le port série
int init_game(Game *g, int il, const char *sp) {
    printf("Init Game...\n"); if (!g) return 0; memset(g, 0, sizeof(Game));
#ifdef _WIN32
    g->serial_handle=INVALID_HANDLE_VALUE;
#else
    g->serial_fd=-1;
#endif
    memset(&g->arduino_state,0,sizeof(ArduinoInputState));
    if(SDL_Init(SDL_INIT_VIDEO|SDL_INIT_TIMER|SDL_INIT_AUDIO)!=0){/*...*/return 0;} if((IMG_Init(IMG_INIT_PNG)&IMG_INIT_PNG)!=IMG_INIT_PNG){/*...*/SDL_Quit();return 0;} if(TTF_Init()==-1){/*...*/IMG_Quit();SDL_Quit();return 0;} if(Mix_OpenAudio(44100,MIX_DEFAULT_FORMAT,2,2048)<0){/*...*/TTF_Quit();IMG_Quit();SDL_Quit();return 0;}
    g->screen=SDL_SetVideoMode(SCREEN_WIDTH,SCREEN_HEIGHT,32,SDL_HWSURFACE|SDL_DOUBLEBUF); if(!g->screen){/*...*/Mix_CloseAudio();TTF_Quit();IMG_Quit();SDL_Quit();return 0;} SDL_WM_SetCaption("P C SDL1.2",NULL); srand(time(NULL)); g->puzzle_font=TTF_OpenFont("arial.ttf",24); if(!g->puzzle_font){fprintf(stderr,"ERR Font arial.ttf\n");cleanup_game(g);return 0;} g->background.timer.font=g->puzzle_font;
    // ** Réactivation init_arduino_input **
    if(!init_arduino_input(g,sp)) {
        fprintf(stderr,"WARN: Arduino init failed %s\n",sp);
    }
    if(!init_minimap(&g->minimap)){cleanup_game(g);return 0;} if(!init_player(&g->player)){cleanup_game(g);return 0;}
    g->enemy_bullet.image=IMG_Load(ENEMY_BULLET_IMAGE_FILE); if(!g->enemy_bullet.image){cleanup_game(g);return 0;} g->enemy_bullet.active=0; g->enemy_bullet.pos.w=g->enemy_bullet.image->w; g->enemy_bullet.pos.h=g->enemy_bullet.image->h;
    g->player_bullet.image=IMG_Load(PLAYER_BULLET_IMAGE_FILE); if(!g->player_bullet.image){cleanup_game(g);return 0;} g->player_bullet.active=0; g->player_bullet.pos.w=g->player_bullet.image->w; g->player_bullet.pos.h=g->player_bullet.image->h;
    g->heart_full_img=IMG_Load(HEART_FULL_FILE); g->heart_empty_img=IMG_Load(HEART_EMPTY_FILE); if(!g->heart_full_img||!g->heart_empty_img){cleanup_game(g);return 0;}
    if (SDL_SetColorKey(g->heart_full_img,SDL_SRCCOLORKEY|SDL_RLEACCEL,SDL_MapRGB(g->heart_full_img->format,0,0,0))!=0) {}
    if (SDL_SetColorKey(g->heart_empty_img,SDL_SRCCOLORKEY|SDL_RLEACCEL,SDL_MapRGB(g->heart_empty_img->format,0,0,0))!=0) {}
    g->obstacle_flash_timer=SDL_GetTicks(); g->running=1; g->game_state=STATE_RUNNING; change_level(g,il); if(!g->running){cleanup_game(g);return 0;} printf("Game Init OK\n"); return 1;
}

void cleanup_game(Game *g) {
    printf("Cleanup Game...\n"); if(!g)return;
    // ** Réactivation cleanup_arduino_input **
    cleanup_arduino_input(g);
    for(int i=0;i<MAX_ENEMIES;++i) { if(g->enemies[i]) { liberer_ennemi(g->enemies[i]); g->enemies[i]=NULL; } }
    free_background(&g->background); free_player(&g->player); if(g->enemy_bullet.image)SDL_FreeSurface(g->enemy_bullet.image); if(g->player_bullet.image)SDL_FreeSurface(g->player_bullet.image); if(g->heart_full_img)SDL_FreeSurface(g->heart_full_img); if(g->heart_empty_img)SDL_FreeSurface(g->heart_empty_img); free_minimap(&g->minimap); if(g->puzzle_font)TTF_CloseFont(g->puzzle_font); Mix_CloseAudio(); TTF_Quit(); IMG_Quit(); SDL_Quit(); printf("Cleanup Done.\n");
}

// --- Arduino Communication Implementation (Fonctions restaurées) ---
int init_arduino_input(Game *g, const char *pn) { if(!g||!pn)return 0; printf(" Init Arduino %s...\n",pn);
#ifdef _WIN32
    g->serial_handle=CreateFile(pn,GENERIC_READ|GENERIC_WRITE,0,NULL,OPEN_EXISTING,0,NULL); if(g->serial_handle==INVALID_HANDLE_VALUE){fprintf(stderr,"  ERR Open %s (%lu)\n",pn,GetLastError());return 0;} DCB dcb={0};dcb.DCBlength=sizeof(dcb); if(!GetCommState(g->serial_handle,&dcb)){fprintf(stderr," GetCommState err\n");CloseHandle(g->serial_handle);g->serial_handle=INVALID_HANDLE_VALUE;return 0;} dcb.BaudRate=CBR_9600;dcb.ByteSize=8;dcb.StopBits=ONESTOPBIT;dcb.Parity=NOPARITY;dcb.fDtrControl=DTR_CONTROL_ENABLE; if(!SetCommState(g->serial_handle,&dcb)){fprintf(stderr," SetCommState err\n");CloseHandle(g->serial_handle);g->serial_handle=INVALID_HANDLE_VALUE;return 0;} COMMTIMEOUTS t={0}; t.ReadIntervalTimeout=MAXDWORD;t.ReadTotalTimeoutConstant=0;t.ReadTotalTimeoutMultiplier=0;t.WriteTotalTimeoutConstant=50;t.WriteTotalTimeoutMultiplier=10; if(!SetCommTimeouts(g->serial_handle,&t)){fprintf(stderr," SetCommTimeouts err\n");CloseHandle(g->serial_handle);g->serial_handle=INVALID_HANDLE_VALUE;return 0;} printf(" Port %s open (Win)\n",pn);
#else
    g->serial_fd=open(pn,O_RDWR|O_NOCTTY|O_NDELAY); if(g->serial_fd==-1){fprintf(stderr,"  ERR Open %s: %s\n",pn,strerror(errno));return 0;} fcntl(g->serial_fd,F_SETFL,O_NONBLOCK); struct termios opt; tcgetattr(g->serial_fd,&opt); cfsetispeed(&opt,B9600); cfsetospeed(&opt,B9600); opt.c_cflag|=(CLOCAL|CREAD); opt.c_cflag&=~PARENB; opt.c_cflag&=~CSTOPB; opt.c_cflag&=~CSIZE; opt.c_cflag|=CS8; opt.c_lflag&=~(ICANON|ECHO|ECHOE|ISIG); opt.c_oflag&=~OPOST; opt.c_cc[VMIN]=0; opt.c_cc[VTIME]=0; tcsetattr(g->serial_fd,TCSANOW,&opt); printf(" Port %s open (Unix)\n",pn);
#endif
    memset(&g->arduino_state,0,sizeof(ArduinoInputState)); g->arduino_buffer[0]='\0'; return 1;}
void cleanup_arduino_input(Game *g) { if(!g) return;
#ifdef _WIN32
    if(g->serial_handle!=INVALID_HANDLE_VALUE){printf(" Close Win port...\n");CloseHandle(g->serial_handle);g->serial_handle=INVALID_HANDLE_VALUE;}
#else
    if(g->serial_fd!=-1){printf(" Close Unix port fd %d...\n",g->serial_fd);close(g->serial_fd);g->serial_fd=-1;}
#endif
}
void read_and_parse_arduino(Game *g) {
    if (!g) return;
#ifdef _WIN32
    if (g->serial_handle == INVALID_HANDLE_VALUE) return;
#else
    if (g->serial_fd == -1) return;
#endif
    char buf[ARDUINO_BUFFER_SIZE];
    int n = 0;

#ifdef _WIN32
    DWORD dwRead = 0;
    if (!ReadFile(g->serial_handle, buf, sizeof(buf) - 1, &dwRead, NULL)) {
        n = -1; // Indiquer une erreur potentielle
    } else {
        n = (int)dwRead;
    }
#else
    n = read(g->serial_fd, buf, sizeof(buf) - 1);
#endif

    // Reset des états événementiels
    g->arduino_state.jump_pressed = 0; g->arduino_state.attack_pressed = 0;
    g->arduino_state.settings_pressed = 0; g->arduino_state.center_pressed = 0;

    if (n > 0) {
        buf[n] = '\0';
        // --- AJOUT DU DEBUG ---
        printf("SERIAL DEBUG: Read %d bytes -> [%s]\n", n, buf);
        fflush(stdout);
        // --- FIN DEBUG ---

        g->arduino_state.is_left_pressed = 0; g->arduino_state.is_right_pressed = 0;
        for (int i = 0; i < n; ++i) {
            char c = buf[i];
            switch (c) {
                case 'L': g->arduino_state.is_left_pressed = 1; break;
                case 'R': g->arduino_state.is_right_pressed = 1; break;
                case 'J': g->arduino_state.jump_pressed = 1; break;
                case 'A': g->arduino_state.attack_pressed = 1; break;
                case 'P': g->arduino_state.settings_pressed = 1; break;
                case 'C': g->arduino_state.center_pressed = 1; break;
                case '\n': case '\r': break; // Ignorer newlines
                default: break; // Ignorer autres caractères
            }
        }
    } else {
        g->arduino_state.is_left_pressed = 0; g->arduino_state.is_right_pressed = 0;
#ifndef _WIN32
        if (n < 0 && errno != EAGAIN && errno != EWOULDBLOCK) {
            perror("Err read serial");
            cleanup_arduino_input(g); // Fermer en cas d'erreur persistante
        }
#endif
    }
}
void send_to_arduino(Game *g, const char *d) { if (!g||!d)return; int len=strlen(d); if(len<=0) return;
#ifdef _WIN32
    if(g->serial_handle==INVALID_HANDLE_VALUE)return; DWORD bw=0; if(!WriteFile(g->serial_handle,d,len,&bw,NULL)){/*err*/} else if(bw!=(DWORD)len){/*warn*/}
#else
    if(g->serial_fd==-1) return; int bw=write(g->serial_fd,d,len); if(bw<0){/*err*/} else if(bw!=len){/*warn*/}
#endif
}

// --- Game Loop Functions ---
void handle_input(Game *g) {
    if(!g) return;
    // ** Appel read_and_parse_arduino réactivé **
    read_and_parse_arduino(g);

    if(g->game_state != STATE_RUNNING) {
        SDL_Event ev; while(SDL_PollEvent(&ev)){if(ev.type==SDL_QUIT||(ev.type==SDL_KEYDOWN&&ev.key.keysym.sym==SDLK_ESCAPE)){g->running=0;return;}}
        // Gérer unpause/quit avec Arduino
        if(g->arduino_state.settings_pressed){if(g->game_state==STATE_PAUSED)g->game_state=STATE_RUNNING;else g->running=0;g->arduino_state.settings_pressed=0;}
        if(g->arduino_state.center_pressed){g->arduino_state.center_pressed=0;} // Ignorer C ici
        return;
    }

    SDL_Event ev; g->keystate=SDL_GetKeyState(NULL); Player *p=&g->player;
    if(p->life_state >= LIFE_STATES - 1) {
        p->vx=0; while(SDL_PollEvent(&ev)){if(ev.type==SDL_QUIT)g->running=0;}
        // Quitter si P, C ou Echap pressé pendant game over
        if(g->arduino_state.settings_pressed || g->arduino_state.center_pressed || g->keystate[SDLK_ESCAPE]) g->running=0;
        return;
    }

    // Appliquer input Arduino (Prioritaire)
    if(g->arduino_state.is_left_pressed && !g->arduino_state.is_right_pressed){p->vx=-PLAYER_SPEED;p->direction=1;}
    else if(g->arduino_state.is_right_pressed && !g->arduino_state.is_left_pressed){p->vx=PLAYER_SPEED;p->direction=0;}
    else { // Fallback clavier si Arduino neutre ou L+R
        if(g->keystate[SDLK_a]&&!g->keystate[SDLK_d]){p->vx=-PLAYER_SPEED;p->direction=1;}
        else if(g->keystate[SDLK_d]&&!g->keystate[SDLK_a]){p->vx=PLAYER_SPEED;p->direction=0;}
        else{p->vx=0;}
    }
    if(g->arduino_state.jump_pressed && p->on_ground){p->vy=JUMP_VELOCITY;p->on_ground=0;g->arduino_state.jump_pressed=0;}
    if(g->arduino_state.attack_pressed && !p->attacking && SDL_GetTicks()-p->last_attack_time>=PLAYER_ATTACK_COOLDOWN){p->attacking=1;p->current_action=ANIM_ATTACK;p->current_frame=0;p->last_frame_time=SDL_GetTicks();p->last_attack_time=SDL_GetTicks();player_shoot(g);g->arduino_state.attack_pressed=0;}
    if(g->arduino_state.settings_pressed){g->game_state=STATE_PAUSED;g->arduino_state.settings_pressed=0;}
    if(g->arduino_state.center_pressed){ /* Action C (OK) différée */ g->arduino_state.center_pressed=0;}

    // Traiter événements clavier restants
    while(SDL_PollEvent(&ev)){ if(ev.type==SDL_QUIT){g->running=0;return;} if(ev.type==SDL_KEYDOWN){ switch(ev.key.keysym.sym){ case SDLK_ESCAPE:g->running=0;return; case SDLK_w: if(!g->arduino_state.jump_pressed&&p->on_ground){p->vy=JUMP_VELOCITY;p->on_ground=0;}break; case SDLK_SPACE: if(!g->arduino_state.attack_pressed&&!p->attacking&&SDL_GetTicks()-p->last_attack_time>=PLAYER_ATTACK_COOLDOWN){p->attacking=1;player_shoot(g);}break; case SDLK_p: if(!g->arduino_state.settings_pressed)g->game_state=STATE_PAUSED; break; case SDLK_RETURN: printf("DBG Puzzle (Kbd)\n");g->game_state=STATE_PUZZLE;break; case SDLK_x: if(g->current_level==1&&g->background.texts[2].is_showing)change_level(g,2); break; case SDLK_o: {int ls=p->life_state;player_take_damage(p,1);if(p->life_state>ls)send_to_arduino(g,"H\n");}break; case SDLK_k: if(g->enemies[0])gerer_sante_ennemi(g->enemies[0],1);break; default: break; }}}
}

void update_game(Game *g) { if(!g||!g->running||g->game_state==STATE_PAUSED||g->game_state==STATE_GAMEOVER||g->game_state!=STATE_RUNNING) return; Player*p=&g->player; Background*bg=&g->background; bool took_dmg=false; g->is_minimap_shaking=0; if(p->life_state>=LIFE_STATES-1){update_camera(bg,p->pos);update_platforms(bg);update_minimap(g);return;} p->vy+=GRAVITY; if(p->vy>MAX_FALL_SPEED)p->vy=MAX_FALL_SPEED; p->on_ground=0; p->pos.x+=(int)p->vx; for(int i=0;i<bg->platform_count;++i){Platform*pl=&bg->platforms[i];if(!pl->image&&pl->type!=ITEM_HOLE)continue;SDL_Rect pr=pl->position;if(check_collision(p->pos,pr)){if(pl->type==PLATFORM_PUZZLE_TRIGGER){g->game_state=STATE_PUZZLE;return;}else if(pl->type!=ITEM_HOLE){if(p->vx>0)p->pos.x=pr.x-p->pos.w;else if(p->vx<0)p->pos.x=pr.x+pr.w;p->vx=0;g->is_minimap_shaking=1;break;}}} if(p->pos.x<0){p->pos.x=0;p->vx=0;} if(p->pos.x+p->pos.w>WORLD_WIDTH){p->pos.x=WORLD_WIDTH-p->pos.w;p->vx=0;} p->pos.y+=(int)p->vy; for(int i=0;i<bg->platform_count;++i){Platform*pl=&bg->platforms[i];if(!pl->image&&pl->type!=ITEM_HOLE)continue;SDL_Rect pr=pl->position;if(check_collision(p->pos,pr)){if(pl->type==PLATFORM_PUZZLE_TRIGGER){g->game_state=STATE_PUZZLE;return;}else if(pl->type!=ITEM_HOLE){float pb=p->pos.y-p->vy+p->pos.h;if(p->vy>0&&pb<=pr.y){p->pos.y=pr.y-p->pos.h;p->on_ground=1;p->vy=0;}else if(p->vy<0){float pt=p->pos.y-p->vy;if(pt>=pr.y+pr.h){p->pos.y=pr.y+pr.h;p->vy=0;}}g->is_minimap_shaking=1;}}} int floor_y=WORLD_FLOOR_Y-p->pos.h;if(p->pos.y>=floor_y){p->pos.y=floor_y;if(p->vy>0)p->vy=0;p->on_ground=1;} update_player_animation(p); update_camera(bg,p->pos); update_platforms(bg); if(!bg->show_final_time)update_timer(&bg->timer); SDL_Rect wl={0,0,WORLD_WIDTH,WORLD_FLOOR_Y+100}; for(int i=0;i<MAX_ENEMIES;++i)if(g->enemies[i]&&g->enemies[i]->health>0){Ennemi*e=g->enemies[i];deplacer_ennemi(e,wl,p->pos);animer_ennemi(e);ennemi_shoot(e,&g->enemy_bullet,p->pos);if(detecter_collision_joueur_ennemi(p->pos,e)){int lb=p->life_state;player_take_damage(p,1);if(p->life_state>lb)took_dmg=true;if(p->pos.x+p->pos.w/2<e->position.x+e->position.w/2)p->vx=-PLAYER_SPEED*1.5f;else p->vx=PLAYER_SPEED*1.5f;p->vy=JUMP_VELOCITY*0.5f;p->on_ground=0;g->is_minimap_shaking=1;}} if(g->enemy_bullet.active){Projectile*eb=&g->enemy_bullet;eb->real_x+=eb->vx;eb->real_y+=eb->vy;eb->pos.x=(int)eb->real_x;eb->pos.y=(int)eb->real_y;int buf=200;if(eb->pos.x<bg->camera.x-eb->pos.w-buf||eb->pos.x>bg->camera.x+SCREEN_WIDTH+buf||eb->pos.y<bg->camera.y-eb->pos.h-buf||eb->pos.y>bg->camera.y+SCREEN_HEIGHT+buf)eb->active=0;else if(check_collision(p->pos,eb->pos)){int lb=p->life_state;player_take_damage(p,1);if(p->life_state>lb)took_dmg=true;eb->active=0;p->vx=(eb->vx>0)?PLAYER_SPEED*0.5f:-PLAYER_SPEED*0.5f;p->vy=-3.0f;p->on_ground=0;g->is_minimap_shaking=1;}} if(g->player_bullet.active){Projectile*pb=&g->player_bullet;pb->real_x+=pb->vx;pb->real_y+=pb->vy;pb->pos.x=(int)pb->real_x;pb->pos.y=(int)pb->real_y;int buf=100;if(pb->pos.x<bg->camera.x-pb->pos.w-buf||pb->pos.x>bg->camera.x+SCREEN_WIDTH+buf||pb->pos.y<bg->camera.y-pb->pos.h-buf||pb->pos.y>bg->camera.y+SCREEN_HEIGHT+buf)pb->active=0;else{for(int i=0;i<MAX_ENEMIES;++i)if(g->enemies[i]&&g->enemies[i]->health>0&&pb->active)if(check_collision(pb->pos,g->enemies[i]->position)){gerer_sante_ennemi(g->enemies[i],1);pb->active=0;break;}}} SDL_Rect feet={p->pos.x+p->pos.w/4,p->pos.y+p->pos.h-5,p->pos.w/2,10};for(int i=0;i<bg->platform_count;++i)if(bg->platforms[i].type==ITEM_HOLE&&bg->platforms[i].image)if(check_collision(feet,bg->platforms[i].position)){int lb=p->life_state;player_take_damage(p,LIFE_STATES);if(p->life_state>lb)took_dmg=true;g->is_minimap_shaking=1;break;} if(took_dmg)send_to_arduino(g,"H\n"); update_minimap(g); }
void render_game(Game *g) { if(!g||!g->screen)return; if(g->game_state==STATE_RUNNING||g->game_state==STATE_GAMEOVER||g->game_state==STATE_PAUSED){render_all(&g->background,g->screen); for(int i=0;i<MAX_ENEMIES;++i)if(g->enemies[i]&&g->enemies[i]->health>0){Ennemi*e=g->enemies[i];afficher_ennemi_on_screen(e,g->screen,g->background.camera);if(g->heart_full_img&&g->heart_empty_img){int hw=g->heart_full_img->w;int tw=(ENNEMI_HEALTH_MAX*hw)+((ENNEMI_HEALTH_MAX-1)*ENEMY_HEART_SPACING);int sx=e->position.x+(e->position.w/2)-(tw/2);int sy=e->position.y+ENEMY_HEALTHBAR_Y_OFFSET;int s_sx=sx-g->background.camera.x;int s_sy=sy-g->background.camera.y;if(s_sx+tw>0&&s_sx<SCREEN_WIDTH&&s_sy+g->heart_full_img->h>0&&s_sy<SCREEN_HEIGHT){ SDL_Rect hpos={s_sx,s_sy,0,0}; for(int h=0;h<ENNEMI_HEALTH_MAX;++h){SDL_Surface*hi=(h<e->health)?g->heart_full_img:g->heart_empty_img;if(hi)SDL_BlitSurface(hi,NULL,g->screen,&hpos);hpos.x+=hw+ENEMY_HEART_SPACING;}}}} render_player(&g->player,g->screen,g->background.camera); if(g->enemy_bullet.active&&g->enemy_bullet.image){ SDL_Rect bsp={g->enemy_bullet.pos.x-g->background.camera.x,g->enemy_bullet.pos.y-g->background.camera.y,0,0}; if(bsp.x<SCREEN_WIDTH&&bsp.x+g->enemy_bullet.pos.w>0&&bsp.y<SCREEN_HEIGHT&&bsp.y+g->enemy_bullet.pos.h>0)SDL_BlitSurface(g->enemy_bullet.image,NULL,g->screen,&bsp);} if(g->player_bullet.active&&g->player_bullet.image){ SDL_Rect bsp={g->player_bullet.pos.x-g->background.camera.x,g->player_bullet.pos.y-g->background.camera.y,0,0}; if(bsp.x<SCREEN_WIDTH&&bsp.x+g->player_bullet.pos.w>0&&bsp.y<SCREEN_HEIGHT&&bsp.y+g->player_bullet.pos.h>0)SDL_BlitSurface(g->player_bullet.image,NULL,g->screen,&bsp);} render_player_hud(&g->player,g->screen); render_minimap(g); if(g->player.life_state>=LIFE_STATES-1){if(g->background.timer.font){char*t="GAME OVER"; SDL_Color c={255,0,0,0}; SDL_Surface*s=TTF_RenderText_Solid(g->background.timer.font,t,c);if(s){ SDL_Rect p={(SCREEN_WIDTH-s->w)/2,(SCREEN_HEIGHT-s->h)/2,0,0}; SDL_BlitSurface(s,NULL,g->screen,&p);SDL_FreeSurface(s);}}} else if(g->game_state==STATE_PAUSED){if(g->background.timer.font){char*t="PAUSED"; SDL_Color c={255,255,255,0}; SDL_Surface*s=TTF_RenderText_Solid(g->background.timer.font,t,c);if(s){ SDL_Rect p={(SCREEN_WIDTH-s->w)/2,(SCREEN_HEIGHT-s->h)/2,0,0}; SDL_Rect bgR=p;bgR.x-=20;bgR.y-=10;bgR.w+=40;bgR.h+=20;SDL_Surface*abg=SDL_CreateRGBSurface(SDL_SRCALPHA,bgR.w,bgR.h,32,0x000000FF,0x0000FF00,0x00FF0000,0xFF000000);if(abg){SDL_FillRect(abg,NULL,SDL_MapRGBA(abg->format,0,0,0,150));SDL_BlitSurface(abg,NULL,g->screen,&bgR);SDL_FreeSurface(abg);}SDL_BlitSurface(s,NULL,g->screen,&p);SDL_FreeSurface(s);}}} if(SDL_Flip(g->screen)==-1){fprintf(stderr,"SDL_Flip err:%s\n",SDL_GetError());g->running=0;} } }
